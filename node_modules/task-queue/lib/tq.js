// Generated by CoffeeScript 1.8.0
(function() {
  var Buffer, Heap, PriorityQueue, Queue, extend,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Buffer = require('cbuffer-resizable');

  Heap = require('binaryheap-resizable');

  extend = function(object, properties) {
    var key, val;
    for (key in properties) {
      val = properties[key];
      object[key] = val;
    }
    return object;
  };

  Queue = (function() {
    function Queue(opts) {
      var _base, _base1, _ref;
      this.opts = opts != null ? opts : {};
      if (!(this instanceof Queue)) {
        return new Queue(opts);
      }
      if (this.opts.capacity == null) {
        throw new Error("Buffer capacity must be passed");
      }
      this.opts._running = (_ref = this.opts.start) != null ? _ref : false;
      this.opts._singleShot = false;
      if ((_base = this.opts).concurrency == null) {
        _base.concurrency = 1;
      }
      if ((_base1 = this.opts).timeout == null) {
        _base1.timeout = 0;
      }
      this._initArray();
    }

    Queue.prototype._initArray = function() {
      return this._array = new Buffer(this.opts.capacity);
    };

    Queue.prototype._exec = function() {
      var actual_concurrency, deq, real_concurrency;
      if (this._running) {
        real_concurrency = actual_concurrency = this.opts.concurrency > this.size() ? this.size() : this.opts.concurrency;
        while (real_concurrency--) {
          if ((deq = this.dequeue()) != null) {
            setImmediate((function(_this) {
              return function() {
                var task_return, _ref, _ref1;
                task_return = deq.method.apply((_ref = deq.context) != null ? _ref : null, (_ref1 = deq.args) != null ? _ref1 : null);
                if (_this.finishedTask != null) {
                  setImmediate(function() {
                    return _this.finishedTask(task_return);
                  });
                }
                if (--actual_concurrency === 0) {
                  if (_this.size() === 0) {
                    if (_this.finished != null) {
                      setImmediate(function() {
                        return _this.finished();
                      });
                    }
                    if (_this._singleShot && _this.size() === 0) {
                      _this._singleShot = false;
                      _this._running = false;
                    }
                  }
                  return setTimeout((function() {
                    return _this._exec();
                  }), _this.opts.timeout);
                }
              };
            })(this));
          }
        }
      }
    };

    Queue.prototype.size = function() {
      return this._array.size;
    };

    Queue.prototype.enqueue = function(fn, opts) {
      var size;
      if (opts == null) {
        opts = {};
      }
      if (this._singleShot) {
        throw new Error("can not enqueue item while single-shooting");
      }
      opts.method = fn;
      size = this._array.push(opts);
      this._exec();
      return size;
    };

    Queue.prototype.dequeue = function() {
      if (this.size() > 0) {
        return this._array.pop();
      } else {
        return null;
      }
    };

    Queue.prototype.concurrency = function(value) {
      if (value == null) {
        return this.opts.concurrency;
      }
      this.opts.concurrency = value;
    };

    Queue.prototype.timeout = function(value) {
      if (value == null) {
        return this.opts.timeout;
      }
      this.opts.timeout = value;
    };

    Queue.prototype.start = function() {
      var wasRunning;
      if (this._singleShot) {
        throw new Error("can not start queue while single-shooting");
      }
      wasRunning = this._running;
      this._running = true;
      if (!wasRunning) {
        this._exec();
      }
    };

    Queue.prototype.stop = function() {
      this._running = false;
      this._singleShot = false;
    };

    Queue.prototype.isRunning = function() {
      return this._running;
    };

    Queue.prototype.options = function(opts) {
      if (opts == null) {
        return this.opts;
      }
      extend(this.opts, opts);
    };

    Queue.prototype.toArray = function() {
      return this._array.toArray();
    };

    Queue.prototype.singleShot = function() {
      if (this._running) {
        throw new Error("can not single-shot a running queue");
      }
      this._running = true;
      this._singleShot = true;
      this._exec();
    };

    return Queue;

  })();

  PriorityQueue = (function(_super) {
    __extends(PriorityQueue, _super);

    function PriorityQueue(opts) {
      if (opts == null) {
        opts = {};
      }
      if (!(this instanceof PriorityQueue)) {
        return new PriorityQueue(opts);
      }
      if (opts.comparator == null) {
        opts.comparator = function(a, b) {
          return a.priority > b.priority;
        };
      }
      PriorityQueue.__super__.constructor.call(this, opts);
    }

    PriorityQueue.prototype._initArray = function() {
      return this._array = new Heap(this.opts.capacity, this.opts.comparator);
    };

    return PriorityQueue;

  })(Queue);

  module.exports = {
    Queue: Queue,
    PriorityQueue: PriorityQueue
  };

}).call(this);
